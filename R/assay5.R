#' @include zzz.R
#' @include layers.R
#' @include logmap.R
#' @importFrom methods setAs
#'
NULL

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Class definitions
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#' Core Assay Infrastructure
#'
#' The \code{StdAssay} class is a virtual class that provides core
#' infrastructure for assay data in \pkg{Seurat}. Assays contain expression
#' data along with additional representations of the expression data (layers)
#' and associated metadata. Derived classes
#' (eg. \link[Assay-class]{the v5 Assay}) must set the storage mechanism for
#' expression data (eg. \code{\link[base]{matrix}} or
#' \code{\link[Matrix:dgCMatrix-class]{dgCMatrix}}) and may optionally define
#' additional functionality
#'
#' @slot data A two-dimensional object with expression data with cells as
#' columns and features as rows
#' @slot layers A named list containing alternate representations of
#' \code{data}; layers must have the same cells as \code{data} and either the
#' same or a subset of the features present in \code{data}
#' @slot key ...
#' @slot cells A vector of cell names present in the assay
#' @slot assay.orig ...
#' @slot features A matrix containing the presence/absence status of features
#' in the layers with the following properties;
#' \itemize{
#'  \item The dimensions of the matrix should be m\emph{f} rows and n\emph{l}
#'  columns where m\emph{f} is the number of features (rows) in \code{data}
#'  and n\emph{l} is the number of layers in \code{layers}
#'  \item The row names should be the features (in order) present in \code{data}
#'  \item The column names should be the names of each layer present in
#'  \code{layers}
#'  \item Each value should be either \code{TRUE} if a given feature is present
#'  in a given layer, otherwise \code{FALSE}
#' }
#' @slot meta.data ...
#' @slot misc ...
#'
#' @exportClass StdAssay
#'
#' @aliases StdAssay
#'
#' @seealso \code{\link{Assay5-class}}
#'
setClass(
  Class = 'StdAssay',
  contains = 'VIRTUAL',
  slots = c(
    layers = 'list',
    key = 'character',
    cells = 'LogMap',
    assay.orig = 'character',
    features = 'LogMap',
    # var.features = 'character',
    meta.data = 'data.frame',
    misc = 'list'
  )
)

#' The v5 \code{Assay} Object
#'
#' The v5 \code{Assay} is the typical \code{Assay} class used in \pkg{Seurat}
#' v5; ...
#'
#' @exportClass Assay5
#'
#' @aliases Assay5
#'
#' @seealso \code{\link{StdAssay-class}}
#'
setClass(
  Class = 'Assay5',
  contains = 'StdAssay'
)

setClass(
  Class = 'Assay5T',
  contains = 'StdAssay'
)

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Functions
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#' Generic Assay Creation
#'
#' Create an assay object; runs a standardized filtering scheme that
#' works regardless of the direction of the data (eg. cells as columns
#' and features as rows or vice versa) and creates an assay object based
#' on the  initialization scheme defined for \code{\link{StdAssay}}-derived
#' class \code{type}
#'
#' @param counts A two-dimensional expression matrix
#' @param min.cells Include features detected in at least this many cells;
#' will subset the counts matrix as well. To reintroduce excluded features,
#' create a new object with a lower cutoff
#' @param min.features Include cells where at least this many features
#' are detected
#' @param cells Vector of cell names
#' @param features Vector of feature names
#' @param layer Name of layer to store \code{counts} as
#' @param type Type of assay object to create; must be the name of a class
#' that's derived from \code{\link{StdAssay}}
#' @param csum Function for calculating cell sums
#' @param fsum Function for calculating feature sums
#' @param ... Extra parameters passed to \code{\link[methods]{new}} for
#' assay creation; used to set slots not defined by \code{\link{StdAssay}}
#'
#' @return An object of class \code{type} with a layer named \code{layer}
#' containing the data found in \code{counts}
#'
#' @importFrom methods getClass
#' @importFrom utils getS3method methods
#'
#' @export
#'
#' @keywords internal
#'
.CreateStdAssay <- function(
  counts,
  min.cells = 0,
  min.features = 0,
  cells = NULL,
  features = NULL,
  layer = 'counts',
  transpose = FALSE,
  type = 'Assay5',
  csum = Matrix::colSums,
  fsum = Matrix::rowSums,
  ...
) {
  # Figure out feature/cell MARGINs
  cdef <- getClass(Class = type)
  contains <- names(x = slot(object = cdef, name = 'contains'))
  if (!'StdAssay' %in% contains) {
    stop("Class '", type, "' does not inherit from StdAssay")
  }
  for (i in c(contains, 'default')) {
    fmargin <- getS3method(f = '.MARGIN', class = i, optional = TRUE)
    if (is.function(x = fmargin)) {
      break
    }
  }
  cdim <- fmargin(object = type, type = 'cells')
  fdim <- fmargin(object = type, type = 'features')
  cells <- cells %||%
    dimnames(x = counts)[[cdim]] %||%
    paste0('Cell_', seq_len(length.out = dim(x = counts)[cdim]))
  features <- features %||%
    dimnames(x = counts)[[fdim]] %||%
    paste0('Feature', seq_len(length.out = dim(x = counts)[fdim]))
  # Filter based on min.features
  if (min.features > 0) {
    cells.use <- which(x = csum(counts > 0) >= min.features)
    counts <- if (cdim == 1) {
      counts[cells.use, ]
    } else {
      counts[, cells.use]
    }
    cells <- cells[cells.use]
  }
  # Filter based on min.cells
  if (min.cells > 0) {
    features.use <- which(x = fsum(counts > 0) >= min.cells)
    counts <- if (fdim == 1) {
      counts[features.use, ]
    } else {
      counts[, features.use]
    }
    features <- features[features.use]
  }
  # Create the object
  object <- new(
    Class = type,
    layers = list(),
    features = LogMap(y = features),
    cells = LogMap(y = cells),
    meta.data = EmptyDF(n = length(x = features)),
    ...
  )
  LayerData(
    object = object,
    layer = layer,
    features = features,
    cells = cells,
    transpose = transpose
  ) <- counts
  return(object)
}

#' Create a v5 Assay object
#'
#' Create an \code{\link{Assay5}} object from a feature expression matrix;
#' the expected format of the matrix is features x cells
#'
#' @inheritParams .CreateStdAssay
#' @param ... Extra parameters passed to \code{\link{.CreateStdAssay}}
#'
#' @return An \code{\link{Assay5}} object
#'
#' @export
#'
CreateAssay5Object <- function(
  counts,
  min.cells = 0,
  min.features = 0,
  layer = 'counts',
  transpose = FALSE,
  ...
) {
  type <- ifelse(test = isTRUE(x = transpose), yes = 'Assay5T', no = 'Assay5')
  if (inherits(x = counts, what = 'spam')) {
    if (isTRUE(x = transpose)) {
      csum <- spam::rowSums
      fsum <- spam::colSums
    } else {
      csum <- spam::colSums
      fsum <- spam::rowSums
    }
  } else {
    if (isTRUE(x = transpose)) {
      csum <- Matrix::rowSums
      fsum <- Matrix::colSums
    } else {
      csum <- Matrix::colSums
      fsum <- Matrix::rowSums
    }
  }
  return(.CreateStdAssay(
    counts = counts,
    min.cells =  min.cells,
    min.features = min.features,
    layer = layer,
    transpose = transpose,
    type = type,
    csum = csum,
    fsum = fsum,
    ...
  ))
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Methods for Seurat-defined generics
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#' @method .AssayClass Assay5T
#' @export
#'
.AssayClass.Assay5T <- function(object) {
  return('Transposed Assay (v5)')
}

#' @method .MARGIN Assay5T
#' @export
#'
.MARGIN.Assay5T <- function(object, type = c('features', 'cells'), ...) {
  type <- type[1]
  type <- match.arg(arg = type)
  return(unname(obj = c(features = 2L, cells = 1L)[type]))
}

#' @rdname AddMetaData
#' @export
#' @method AddMetaData StdAssay
#'
AddMetaData.StdAssay <- .AddMetaData

#' @rdname Cells
#' @method Cells StdAssay
#' @export
#'
Cells.StdAssay <- function(x, layer = NULL, ...) {
  if (isTRUE(x = is.na(x = layer))) {
    return(rownames(x = slot(object = x, name = 'cells')))
  }
  layer <- layer %||% DefaultLayer(object = x)
  return(slot(object = x, name = 'cells')[[layer]])
}

#' @rdname DefaultAssay
#' @export
#' @method DefaultAssay StdAssay
#'
DefaultAssay.StdAssay <- function(object, ...) {
  return(slot(object = object, name = 'assay.orig'))
}

#' @rdname DefaultAssay
#' @export
#' @method DefaultAssay<- StdAssay
#'
"DefaultAssay<-.StdAssay" <- function(object, ..., value) {
  slot(object = object, name = 'assay.orig') <- value
  return(object)
}

#' @rdname DefaultLayer
#' @export
#' @method DefaultLayer StdAssay
#'
DefaultLayer.StdAssay <- function(object, ...) {
  return(Layers(object = object)[1])
}

#' @rdname DefaultLayer
#' @export
#' @method DefaultLayer<- StdAssay
#'
"DefaultLayer<-.StdAssay" <- function(object, ..., value) {
  value <- value[1]
  layers <- Layers(object = object)
  value <- match.arg(arg = value, choices = layers)
  idx <- which(x = layers == value)
  slot(object = object, name = 'layers') <- c(
    slot(object = object, name = 'layers')[idx],
    slot(object = object, name = 'layers')[-idx]
  )
  return(object)
}

#' @param layer
#'
#' @rdname Cells
#' @export
#' @method Features StdAssay
#'
Features.StdAssay <- function(x, layer = NULL, ...) {
  if (isTRUE(x = is.na(x = layer))) {
    return(rownames(x = slot(object = x, name = 'features')))
  }
  layer <- layer %||% DefaultLayer(object = x)
  return(slot(object = x, name = 'features')[[layer]])
}

#' @rdname AssayData
#' @export
#' @method GetAssayData StdAssay
#'
#' @examples
#' \dontrun{
#' # Get the data directly from an Assay object
#' GetAssayData(pbmc_small[["RNA"]], slot = "data")[1:5,1:5]
#' }
#'
GetAssayData.StdAssay <- function(object, slot = 'data', ...) {
  CheckDots(..., fxns = LayerData)
  return(LayerData(object = object, layer = slot, ...))
}

#' @rdname VariableFeatures
#' @export
#' @method HVFInfo StdAssay
#'
#' @examples
#' \dontrun{
#' # Get the HVF info directly from an Assay object
#' HVFInfo(pbmc_small[["RNA"]], selection.method = 'vst')[1:5, ]
#' }
#'
HVFInfo.StdAssay <- function(object, selection.method, status = FALSE, ...) {
  .NotYetImplemented()
  CheckDots(...)
  disp.methods <- c('mean.var.plot', 'dispersion', 'disp')
  if (tolower(x = selection.method) %in% disp.methods) {
    selection.method <- 'mvp'
  }
  selection.method <- switch(
    EXPR = tolower(x = selection.method),
    'sctransform' = 'sct',
    selection.method
  )
  vars <- switch(
    EXPR = selection.method,
    'vst' = c('mean', 'variance', 'variance.standardized'),
    'mvp' = c('mean', 'dispersion', 'dispersion.scaled'),
    'sct' = c('gmean', 'variance', 'residual_variance'),
    stop("Unknown method: '", selection.method, "'", call. = FALSE)
  )
  tryCatch(
    expr = hvf.info <- object[[paste(selection.method, vars, sep = '.')]],
    error = function(e) {
      stop(
        "Unable to find highly variable feature information for method '",
        selection.method,
        "'",
        call. = FALSE
      )
    }
  )
  colnames(x = hvf.info) <- vars
  if (status) {
    hvf.info$variable <- object[[paste0(selection.method, '.variable')]]
  }
  return(hvf.info)
}

#' @rdname Key
#' @export
#' @method Key StdAssay
#'
#' @examples
#' \dontrun{
#' # Get an Assay key
#' Key(pbmc_small[["RNA"]])
#' }
#'
Key.StdAssay <- function(object, ...) {
  CheckDots(...)
  return(slot(object = object, name = 'key'))
}

#' @rdname Key
#' @export
#' @method Key<- StdAssay
#'
#' @examples
#' \dontrun{
#' # Set the key for an Assay
#' Key(pbmc_small[["RNA"]]) <- "newkey_"
#' Key(pbmc_small[["RNA"]])
#' }
#'
"Key<-.StdAssay" <- function(object, ..., value) {
  CheckDots(...)
  slot(object = object, name = 'key') <- UpdateKey(key = value)
  return(object)
}

#' @param fast Determine how to return the layer data; choose from:
#' \describe{
#'  \item{\code{FALSE}}{Apply any transpositions and attempt to add feature/cell
#'   names (if supported) back to the layer data}
#'  \item{\code{NA}}{Attempt to add feature/cell names back to the layer data,
#'   skip any transpositions}
#'  \item{\code{TRUE}}{Do not apply any transpositions or add feature/cell names
#'   to the layer data}
#' }
#'
#' @rdname Layers
#' @method LayerData StdAssay
#' @export
#'
LayerData.StdAssay <- function(object, layer = NULL, fast = FALSE, ...) {
  layer <- layer[1] %||% DefaultLayer(object = object)
  layer <- match.arg(arg = layer, choices = Layers(object = object))
  ldat <- slot(object = object, name = 'layers')[[layer]]
  dnames <- list(
    Features(x = object, layer = layer),
    Cells(x = object, layer = layer)
  )
  ldat <- if (isTRUE(x = fast)) {
    ldat
  } else if (is.na(x = fast)) {
    .GetLayerData(
      x = ldat,
      dnames = dnames,
      fmargin = 1L,
      ...
    )
  } else {
    .GetLayerData(
      x = ldat,
      dnames = dnames,
      fmargin = .MARGIN(object = object, type = 'features'),
      ...
    )
  }
  return(ldat)
}

#' @param features,cells Vectors of features/cells to include ...
#'
#' @rdname Layers
#' @method LayerData<- StdAssay
#' @export
#'
"LayerData<-.StdAssay" <- function(
  object,
  layer,
  features = NULL,
  cells = NULL,
  ...,
  value
) {
  # Remove a layer
  if (is.null(x = value)) {
    if (length(x = Layers(object = object)) == 1L) {
      stop("Cannot remove only layer")
    } else if (layer == DefaultLayer(object = object)) {
      DefaultLayer(object = object) <- Layers(object = object)[2]
      warning(
        "Removing default layer, setting default to ",
        DefaultLayer(object = object),
        call. = FALSE,
        immediate. = TRUE
      )
    }
    slot(object = object, name = 'layers')[[layer]] <- NULL
    maps <- c(
      'cells',
      'features'
    )
    for (i in maps) {
      slot(object = object, name = i)[[layer]] <- NULL
    }
    validObject(object = object)
    return(object)
  }
  # Add a layer
  fdim <- .MARGIN(object = object, type = 'features')
  cdim <- .MARGIN(object = object, type = 'cells')
  # Assume input matrix is features x cells
  dnames <- list(
    # features %||% dimnames(x = value)[[fdim]],
    features %||% dimnames(x = value)[[1L]],
    # cells %||% dimnames(x = value)[[cdim]]
    cells %||% dimnames(x = value)[[2L]]
  )
  if (length(x = unique(x = dim(x = value))) > 1L) {
    didx <- match(
      x = vapply(
        X = dnames,
        FUN = length,
        FUN.VALUE = numeric(length = 1L),
        USE.NAMES = FALSE
      ),
      table = dim(x = value)
    )
    dnames <- dnames[didx]
  }
  value <- .PrepLayerData(
    x = value,
    target = dim(x = object),
    dnames = dnames,
    fmargin = fdim,
    ...
  )
  # Check features and cells
  features <- attr(x = value, which = 'features') %||% seq_len(length.out = dim(x = value)[fdim])
  cells <- attr(x = value, which = 'cells') %||% seq_len(length.out = dim(x = value)[cdim])
  fmatch <- MatchCells(
    new = features,
    orig = rownames(x = slot(object = object, name = 'features')),
    ordered = TRUE
  )
  cmatch <- MatchCells(
    new = cells,
    orig = rownames(x = slot(object = object, name = 'cells')),
    ordered = TRUE
  )
  if (is.null(x = fmatch)) {
    stop(
      "No feature overlap between existing object and new layer data",
      call. = FALSE
    )
  } else if (is.null(x = cmatch)) {
    stop(
      "No cell overlap between existing object and new layer data",
      call. = FALSE
    )
  }
  features <- features[fmatch]
  cells <- cells[cmatch]
  # Check for existing layer data
  if (layer %in% Layers(object = object)) {
    fcheck <- if (is.numeric(x = features)) {
      Features(x = object, layer = layer)[features]
    } else {
      features
    }
    ccheck <- if (is.numeric(x = cells)) {
      Cells(object = object, layer = layer)[cells]
    } else {
      cells
    }
    if (!identical(x = fcheck, y = Features(x = object, layer = layer))) {
      warning(
        "Different features in new layer data than already exists for ",
        layer,
        call. = FALSE,
        immediate. = TRUE
      )
    }
    if (!identical(x = ccheck, y = Cells(x = object, layer = layer))) {
      warning(
        "Different cells in new layer data than already exists for ",
        layer,
        call. = FALSE,
        immediate. = TRUE
      )
    }
  }
  # Reorder the layer data
  vdims <- list(fmatch, cmatch)
  names(x = vdims) <- c('i', 'j')[c(fdim, cdim)]
  value <- do.call(what = '[', args = c(list(x = value), vdims))
  # Add the layer
  slot(object = object, name = 'layers')[[layer]] <- value
  # Update the maps
  slot(object = object, name = 'features')[[layer]] <- features
  slot(object = object, name = 'cells')[[layer]] <- cells
  validObject(object = object)
  return(object)
}

#' @rdname Layers
#' @method Layers StdAssay
#' @export
#'
Layers.StdAssay <- function(object, ...) {
  layers <- names(x = slot(object = object, name = 'layers'))
  return(layers)
}

#' @param slot Name of specific bit of meta data to pull
#'
#' @rdname Misc
#' @export
#' @method Misc StdAssay
#'
Misc.StdAssay <- .Misc

#' @rdname Misc
#' @export
#' @method Misc<- StdAssay
#'
"Misc<-.StdAssay" <- `.Misc<-`

#' @importFrom stats na.omit
#'
#' @rdname AssayData
#' @export
#' @method SetAssayData StdAssay
#'
#' @examples
#' \dontrun{
#' # Set an Assay slot directly
#' count.data <- GetAssayData(pbmc_small[["RNA"]], slot = "counts")
#' count.data <- as.matrix(x = count.data + 1)
#' new.assay <- SetAssayData(pbmc_small[["RNA"]], slot = "counts", new.data = count.data)
#' }
#'
SetAssayData.StdAssay <- function(object, slot, new.data, ...) {
  .NotYetImplemented()
  LayerData(object = object, layer = slot) <- new.data
  return(object)
  CheckDots(...)
  slot <- slot[1]
  # slot <- match.arg(arg = slot, choices = '')
  if (!IsMatrixEmpty(x = new.data)) {
    if (any(grepl(pattern = '_', x = rownames(x = new.data)))) {
      warning(
        "Feature names cannot have underscores ('_'), replacing with dashes ('-')",
        call. = FALSE,
        immediate. = TRUE
      )
      rownames(x = new.data) <- gsub(
        pattern = '_',
        replacement = '-',
        x = rownames(x = new.data)
      )
    }
    if (ncol(x = new.data) != ncol(x = object)) {
      stop(
        "The new data doesn't have the same number of cells as the current data",
        call. = FALSE
      )
    }
    num.counts <- nrow(x = object)
    counts.names <- rownames(x = object)
    if (slot == 'scale.data' && nrow(x = new.data) > num.counts) {
      warning(
        "Adding more features than present in current data",
        call. = FALSE,
        immediate. = TRUE
      )
    } else if (slot %in% c('counts', 'data') && nrow(x = new.data) != num.counts) {
      warning(
        "The new data doesn't have the same number of features as the current data",
        call. = FALSE,
        immediate. = TRUE
      )
    }
    if (!all(rownames(x = new.data) %in% counts.names)) {
      warning(
        "Adding features not currently present in the object",
        call. = FALSE,
        immediate. = TRUE
      )
    }
    new.features <- na.omit(object = match(
      x = counts.names,
      table = rownames(x = new.data)
    ))
    new.cells <- colnames(x = new.data)
    if (!all(new.cells %in% colnames(x = object))) {
      stop(
        "All cell names must match current cell names",
        call. = FALSE
      )
    }
    new.data <- new.data[new.features, colnames(x = object), drop = FALSE]
    if (slot %in% c('counts', 'data') && !all(dim(x = new.data) == dim(x = object))) {
      stop(
        "Attempting to add a different number of cells and/or features",
        call. = FALSE
      )
    }
  }
  if (!is.vector(x = rownames(x = new.data))) {
    rownames(x = new.data) <- as.vector(x = rownames(x = new.data))
  }
  if (!is.vector(x = colnames(x = new.data))) {
    colnames(x = new.data) <- as.vector(x = colnames(x = new.data))
  }
  slot(object = object, name = slot) <- new.data
  return(object)
}

#' @rdname VariableFeatures
#' @export
#' @method VariableFeatures StdAssay
#'
VariableFeatures.StdAssay <- function(object, selection.method = NULL, ...) {
  .NotYetImplemented()
  CheckDots(...)
  if (!is.null(x = selection.method)) {
    vf <- HVFInfo(
      object = object,
      selection.method = selection.method,
      status = TRUE
    )
    return(rownames(x = vf)[which(x = vf[, "variable"][, 1])])
  }
  return(slot(object = object, name = 'var.features'))
}

#' @rdname VariableFeatures
#' @export
#' @method VariableFeatures<- StdAssay
#'
"VariableFeatures<-.StdAssay" <- function(object, ..., value) {
  .NotYetImplemented()
  CheckDots(...)
  if (length(x = value) == 0) {
    slot(object = object, name = 'var.features') <- character(length = 0)
    return(object)
  }
  if (any(grepl(pattern = '_', x = value))) {
    warning(
      "Feature names cannot have underscores '_', replacing with dashes '-'",
      call. = FALSE,
      immediate = TRUE
    )
    value <- gsub(pattern = '_', replacement = '-', x = value)
  }
  value <- split(x = value, f = value %in% rownames(x = object))
  if (length(x = value[['FALSE']]) > 0) {
    if (length(x = value[['TRUE']]) == 0) {
      stop(
        "None of the features provided are in this Assay object",
        call. = FALSE
      )
    } else {
      warning(
        "Not all features provided are in this Assay object, removing the following feature(s): ",
        paste(value[['FALSE']], collapse = ', '),
        call. = FALSE,
        immediate. = TRUE
      )
    }
  }
  slot(object = object, name = 'var.features') <- value[['TRUE']]
  return(object)
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Methods for R-defined generics
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#' \code{StdAssay} Methods
#'
#' Methods for \code{\link{StdAssay}} objects for generics defined in
#' other packages
#'
#' @param x,object An \code{\link{StdAssay}} object
#' @param i,features For \code{[[}: metadata names; for all other methods,
#' feature names or indices
#' @param j,cells Cell names or indices
#' @param ... Arguments passed to other methods
#'
#' @details The following methods are provided for interacting with a
#' \code{StdAssay} object
#'
#' @name StdAssay-methods
#' @rdname StdAssay-methods
#'
#' @concept assay
#'
NULL

#' @details \code{[}: Get expression data from an \code{StdAssay}
#'
#' @return \code{[}: The \code{data} slot for features \code{i} and cells
#' \code{j}
#'
#' @rdname StdAssay-methods
#'
#' @method [ StdAssay
#' @export
#'
"[.StdAssay" <- function(x, i, j, ...) {
  if (missing(x = i)) {
    i <- seq_len(length.out = nrow(x = x))
  }
  if (missing(x = j)) {
    j <- seq_len(length.out = ncol(x = x))
  }
  return(GetAssayData(object = x)[i, j, ..., drop = FALSE])
}

#' @details \code{[[}: Get feature-level metadata
#'
#' @param drop See \code{\link[base]{drop}}
#'
#' @return \code{[[}: The feature-level metadata for \code{i}
#'
#' @rdname StdAssay-methods
#'
#' @method [[ StdAssay
#' @export
#'
"[[.StdAssay" <- function(x, i, ..., drop = FALSE) {
  if (missing(x = i)) {
    i <- colnames(x = slot(object = x, name = 'meta.data'))
  }
  data.return <- slot(object = x, name = 'meta.data')[, i, drop = FALSE, ...]
  row.names(x = data.return) <- Features(x = x, layer = NA)
  if (drop) {
    data.return <- unlist(x = data.return, use.names = FALSE)
    names(x = data.return) <- rep.int(x = rownames(x = x), times = length(x = i))
  }
  return(data.return)
}

#' @details \code{dim}: Number of cells and features for an \code{StdAssay}
#'
#' @return \code{dim}: The number of features (\code{nrow}) and cells
#' (\code{ncol})
#'
#' @rdname StdAssay-methods
#'
#' @method dim StdAssay
#' @export
#'
dim.StdAssay <- function(x) {
  return(vapply(
    X = c('features', 'cells'),
    FUN = function(s) {
      return(nrow(x = slot(object = x, name = s)))
    },
    FUN.VALUE = numeric(length = 1L),
    USE.NAMES = FALSE
  ))
}

#' @details \code{dimnames}: Get the feature and cell names
#'
#' @return \code{dimnames}: A list with feature (row) and cell (column) names
#'
#' @rdname StdAssay-methods
#'
#' @method dimnames StdAssay
#' @export
#'
#' @seealso \code{\link{Cells}} \code{\link{Features}}
#'
dimnames.StdAssay <- function(x) {
  return(list(Features(x = x), Cells(x = x)))
}

#' @details \code{head} and \code{tail}: Get the first or last rows of feature
#' level meta data
#'
#' @return \code{head}: The first \code{n} rows of feature-level metadata
#'
#' @importFrom utils head
#'
#' @rdname StdAssay-methods
#'
#' @method head StdAssay
#' @export
#'
head.StdAssay <- .head

#' @return \code{tail}: The last \code{n} rows of feature-level metadata
#'
#' @importFrom utils tail
#'
#' @rdname StdAssay-methods
#'
#' @method tail StdAssay
#' @export
#'
tail.StdAssay <- .tail

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Internal
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

CalcN5 <- function(object) {
  if (IsMatrixEmpty(x = LayerData(object = object))) {
    return(NULL)
  }
  return(list(
    nCount = colSums(x = object),
    nFeature = colSums(x = LayerData(object = object) > 0)
  ))
}

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# S4 methods
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#' @details \code{[[<-}: Add or remove pieces of meta data
#'
#' @return \code{[[<-}: \code{x} with the metadata updated
#'
#' @rdname StdAssay-methods
#'
setMethod(
  f = '[[<-',
  signature = c(
    x = 'StdAssay',
    i = 'character',
    j = 'missing',
    value = 'data.frame'
  ),
  definition = function(x, i, ..., value) {
    i <- match.arg(arg = i, choices = colnames(x = value), several.ok = TRUE)
    names.intersect <- intersect(
      x = row.names(x = value),
      y = Features(x = x, layer = NA)
    )
    if (length(x = names.intersect)) {
      value <- value[names.intersect, , drop = FALSE]
    } else if (nrow(x = value) == nrow(x = x)) {
      row.names(x = value) <- Features(x = x, layer = NA)
    } else {
      stop(
        "Cannot add more or less meta data without feature names",
        call. = FALSE
      )
    }
    for (n in i) {
      v <- value[[n]]
      names(x = v) <- row.names(value)
      x[[n]] <- v
    }
    return(x)
  }
)

#' @importFrom methods selectMethod
#'
#' @rdname StdAssay-methods
#'
setMethod(
  f = '[[<-',
  signature = c(x = 'StdAssay', i = 'character', j = 'missing', value = 'factor'),
  definition = function(x, i, ..., value) {
    f <- slot(
      object = selectMethod(
        f = '[[<-',
        signature = c(
          x = 'StdAssay',
          i = 'character',
          j = 'missing',
          value = 'vector'
        )
      ),
      name = '.Data'
    )
    return(f(x = x, i = i, value = value))
  }
)

#' @rdname StdAssay-methods
#'
setMethod(
  f = '[[<-',
  signature = c(x = 'StdAssay', i = 'character', j = 'missing', value = 'NULL'),
  definition = function(x, i, ..., value) {
    for (name in i) {
      slot(object = x, name = 'meta.data')[[name]] <- NULL
    }
    return(x)
  }
)

#' @rdname StdAssay-methods
#'
setMethod(
  f = '[[<-',
  signature = c(x = 'StdAssay', i = 'character', j = 'missing', value = 'vector'),
  definition = function(x, i, ..., value) {
    # Add multiple bits of metadata
    if (length(x = i) > 1L) {
      value <- rep_len(x = value)
      for (idx in seq_along(along.with = i)) {
        x[i[idx]] <- value[[idx]]
      }
    } else {
      # Add a single column of metadata
      if (is.null(x = names(x = value))) {
        value <- rep_len(x = value, length.out = nrow(x = x))
        names(x = value) <- Features(x = x, layer = NA)
      } else {
        names.intersect <- intersect(
          x = names(x = value),
          y = Features(x = x, layer = NA)
        )
        if (!length(x = names.intersect)) {
          stop(
            "No feature overlap between new meta data and assay",
            call. = FALSE
          )
        }
        value <- value[names.intersect]
      }
      df <- EmptyDF(n = nrow(x = x))
      rownames(x = df) <- Features(x = x, layer = NA)
      df[[i]] <- NA
      df[names(x = value), i] <- value
      slot(object = x, name = 'meta.data')[, i] <- df[[i]]
    }
    validObject(object = x)
    return(x)
  }
)

#' @rdname StdAssay-methods
#'
setMethod(
  f = '[[<-',
  signature = c(x = 'StdAssay', i = 'numeric', j = 'missing', value = 'ANY'),
  definition = function(x, i, ..., value) {
    if (ncol(x = x[[]])) {
      i <- colnames(x = x[[]])[as.integer(x = i)]
      i <- i[!is.na(x = i)]
      if (length(x = i)) {
        x[[i]] <- value
      }
    }
    return(x)
  }
)

#' @rdname StdAssay-methods
#'
setMethod(
  f = '[[<-',
  signature = c(
    x = 'StdAssay',
    i = 'missing',
    j = 'missing',
    value = 'data.frame'
  ),
  definition = function(x, ..., value) {
    x[[colnames(x = value)]] <- value
    return(x)
  }
)

#' @rdname StdAssay-methods
#'
setMethod(
  f = '[[<-',
  signature = c(x = 'StdAssay', i = 'missing', j = 'missing', value = 'NULL'),
  definition = function(x, ..., value) {
    slot(object = x, name = 'meta.data') <- EmptyDF(n = nrow(x = x))
    return(x)
  }
)

setMethod(
  f = 'colMeans',
  signature = c(x = 'StdAssay'),
  definition = function(x, na.rm = FALSE, dims = 1, layer = NULL, ...) {
    return(Matrix::colMeans(
      x = LayerData(object = x, layer = layer),
      na.rm = na.rm,
      dims = dims
    ))
  }
)

setMethod(
  f = 'colSums',
  signature = c(x = 'StdAssay'),
  definition = function(x, na.rm = FALSE, dims = 1, layer = NULL, ...) {
    return(Matrix::colSums(
      x = LayerData(object = x, layer = layer),
      na.rm = na.rm,
      dims = dims
    ))
  }
)

setMethod(
  f = 'rowMeans',
  signature = c(x = 'StdAssay'),
  definition = function(x, na.rm = FALSE, dims = 1, layer = NULL, ...) {
    return(Matrix::rowMeans(
      x = LayerData(object = x, layer = layer),
      na.rm = na.rm,
      dims = dims
    ))
  }
)

setMethod(
  f = 'rowSums',
  signature = c(x = 'StdAssay'),
  definition = function(x, na.rm = FALSE, dims = 1, layer = NULL, ...) {
    return(Matrix::rowSums(
      x = LayerData(object = x, layer = layer),
      na.rm = na.rm,
      dims = dims
    ))
  }
)

#' @details \code{show}: Overview of an \code{StdAssay} object
#'
#' @return \code{show}: Prints summary to \code{\link[base]{stdout}} and
#' invisibly returns \code{NULL}
#'
#' @importFrom utils head
#' @importFrom methods show
#'
#' @rdname StdAssay-methods
#'
setMethod(
  f = 'show',
  signature = 'StdAssay',
  definition = function(object) {
    # Basic assay info
    cat(
      .AssayClass(object = object),
      'data with',
      nrow(x = object),
      'features for',
      ncol(x = object), 'cells\n'
    )
    # Feature information
    # if (length(x = VariableFeatures(object = object)) > 0) {
    if (FALSE) {
      top.ten <- head(x = VariableFeatures(object = object), n = 10L)
      top <- 'Top'
      variable <- 'variable'
    } else {
      top.ten <- head(x = Features(x = object), n = 10L)
      top <- 'First'
      variable <- ''
    }
    features <- paste0(
      variable,
      ' feature',
      if (length(x = top.ten) != 1) {
        's'
      },
      ":\n"
    )
    features <- gsub(pattern = '^\\s+', replacement = '', x = features)
    cat(
      top,
      length(x = top.ten),
      features,
      paste(strwrap(x = paste(top.ten, collapse = ', ')), collapse = '\n'),
      '\n'
    )
    cat("Default layer:", DefaultLayer(object = object) %||% "NULL")
    # Layer information
    layers <- setdiff(
      x = Layers(object = object),
      y = DefaultLayer(object = object)
    )
    if (length(x = layers)) {
      cat(
        "\nAdditional layers:\n",
        paste(strwrap(x = paste(layers, collapse = ', ')), collapse = '\n'),
        "\n"
      )
    }
    return(invisible(x = NULL))
  }
)

setValidity(
  Class = 'StdAssay',
  method = function(object) {
    valid <- NULL
    # Check layers
    dorder <- c(
      features = .MARGIN(object = object, type = 'features'),
      cells = .MARGIN(object = object, type = 'cells')
    )
    adims <- dim(x = object) # c(features, cells)
    if (!IsNamedList(x = slot(object = object, name = 'layers'), pass.zero = TRUE)) {
      valid <- c(valid, "'layers' must be a named list")
    }
    for (layer in Layers(object = object)) {
      # Reorder dimensions of layer to c(features, cells)
      ldims <- dim(x = slot(object = object, name = 'layers')[[layer]])[dorder]
      if (length(x = ldims) != 2L) {
        valid <- c(valid, "Layers must be two-dimensional objects")
        break
      }
      # Check that we have the correct features and cells
      for (i in seq.int(from = 1L, to = 2L)) {
        if (ldims[i] > adims[i]) {
          valid <- c(
            valid,
            paste0(
              "Layers may not have more ",
              names(x = dorder)[i],
              " than present in the assay (offending layer",
              layer,
              ")"
            )
          )
        }
      }
      # Check that we've recorded the cells and features in the maps
      for (i in c('cells', 'features')) {
        didx <- c(features = 1L, cells = 2L)[i]
        if (!layer %in% colnames(x = slot(object = object, name = i))) {
          valid <- c(
            valid,
            paste0(
              "All layers must have a record in the ",
              i,
              " map (offending layer: ",
              layer,
              ")"
            )
          )
        } else {
          nmap <- length(x = slot(object = object, name = i)[[layer]])
          if (nmap != ldims[didx]) {
            valid <- c(
              valid,
              paste0(
                "Layers must have the same ",
                i,
                " as present in the map (offending layer: ",
                layer,
                ")"
              )
            )
          }
        }
      }
    }
    # TODO: Check variable features
    # TODO: Check meta features
    # TODO: Check key
    # TODO: Check misc
    return(valid %||% TRUE)
  }
)
